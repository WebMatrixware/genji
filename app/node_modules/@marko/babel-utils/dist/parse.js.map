{"version":3,"sources":["../src/parse.js"],"names":["CODE_AS_WHITE_SPACE_KEY","Symbol","parseScript","file","str","start","tryParse","parseExpression","isExpression","whitespace","metadata","marko","undefined","code","replace","slice","babelParser","opts","parse","program","err","loc","message","buildCodeFrameError"],"mappings":"0MAAA;;AAEA,MAAMA,uBAAuB,GAAGC,MAAM,EAAtC;;AAEO,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,GAA3B,EAAgCC,KAAhC,EAAuC;AAC5C,SAAOC,QAAQ,CAACH,IAAD,EAAO,KAAP,EAAcC,GAAd,EAAmBC,KAAnB,CAAf;AACD;;AAEM,SAASE,eAAT,CAAyBJ,IAAzB,EAA+BC,GAA/B,EAAoCC,KAApC,EAA2C;AAChD,SAAOC,QAAQ,CAACH,IAAD,EAAO,IAAP,EAAaC,GAAb,EAAkBC,KAAlB,CAAf;AACD;;AAED,SAASC,QAAT,CAAkBH,IAAlB,EAAwBK,YAAxB,EAAsCJ,GAAtC,EAA2CC,KAA3C,EAAkD;AAChD,MAAIA,KAAJ,EAAW;AACT,QAAII,UAAU,GAAGN,IAAI,CAACO,QAAL,CAAcC,KAAd,CAAoBX,uBAApB,CAAjB;;AAEA,QAAIS,UAAU,KAAKG,SAAnB,EAA8B;AAC5BT,MAAAA,IAAI,CAACO,QAAL,CAAcC,KAAd;AACEX,MAAAA,uBADF;AAEIS,MAAAA,UAAU,GAAGN,IAAI,CAACU,IAAL,CAAUC,OAAV,CAAkB,QAAlB,EAA4B,GAA5B,CAFjB;AAGD;;AAEDV,IAAAA,GAAG,GAAGK,UAAU,CAACM,KAAX,CAAiB,CAAjB,EAAoBV,KAApB,IAA6BD,GAAnC;AACD;;AAED,MAAI;AACF,WAAOI,YAAY;AACfQ,IAAAA,WAAW,CAACT,eAAZ,CAA4BH,GAA5B,EAAiCD,IAAI,CAACc,IAAtC,CADe;AAEfD,IAAAA,WAAW,CAACE,KAAZ,CAAkBd,GAAlB,EAAuBD,IAAI,CAACc,IAA5B,EAAkCE,OAFtC;AAGD,GAJD,CAIE,OAAOC,GAAP,EAAY;AACZ,QAAI,EAAEC,GAAF,EAAOC,OAAP,KAAmBF,GAAvB;AACA,QAAIC,GAAJ,EAAS;AACP,YAAMlB,IAAI,CAACoB,mBAAL;AACJ,QAAEF,GAAG,EAAE,EAAEhB,KAAK,EAAEgB,GAAT,EAAP,EADI;AAEJC,MAAAA,OAAO,CAACR,OAAR,CAAgB,gBAAhB,EAAkC,EAAlC,CAFI,CAAN;;AAID,KALD,MAKO;AACL,YAAMM,GAAN;AACD;AACF;AACF","sourcesContent":["import * as babelParser from \"@babel/parser\";\n\nconst CODE_AS_WHITE_SPACE_KEY = Symbol();\n\nexport function parseScript(file, str, start) {\n  return tryParse(file, false, str, start);\n}\n\nexport function parseExpression(file, str, start) {\n  return tryParse(file, true, str, start);\n}\n\nfunction tryParse(file, isExpression, str, start) {\n  if (start) {\n    let whitespace = file.metadata.marko[CODE_AS_WHITE_SPACE_KEY];\n\n    if (whitespace === undefined) {\n      file.metadata.marko[\n        CODE_AS_WHITE_SPACE_KEY\n      ] = whitespace = file.code.replace(/[^\\s]/g, \" \");\n    }\n\n    str = whitespace.slice(0, start) + str;\n  }\n\n  try {\n    return isExpression\n      ? babelParser.parseExpression(str, file.opts)\n      : babelParser.parse(str, file.opts).program;\n  } catch (err) {\n    let { loc, message } = err;\n    if (loc) {\n      throw file.buildCodeFrameError(\n        { loc: { start: loc } },\n        message.replace(/ *\\(\\d+:\\d+\\)$/, \"\")\n      );\n    } else {\n      throw err;\n    }\n  }\n}\n"],"file":"parse.js"}