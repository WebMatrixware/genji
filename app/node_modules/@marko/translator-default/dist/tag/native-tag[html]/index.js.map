{"version":3,"sources":["../../../src/tag/native-tag[html]/index.js"],"names":["EMPTY_OBJECT","path","isNullable","hub","file","node","key","name","body","handlers","tagProperties","tagDef","meta","metadata","marko","parseOptions","import","deps","push","dir","Object","entries","forEach","eventName","arguments","args","once","delegateArgs","t","stringLiteral","booleanLiteral","length","arrayExpression","slice","objectProperty","callExpression","memberExpression","_componentDefIdentifier","identifier","isHTML","markoOpts","output","dataMarko","preserveAttrs","map","hasStatefulTagParams","hasComponentBrowser","hasComponent","isPreserved","dataMarkoArgs","objectExpression","numericLiteral","translatedAttrs","get","isSelfClosing","openTagEnding","isStringLiteral","htmlType","SELF_CLOSING","voidElements","indexOf","value","isEmpty","writeStartNode","ifStatement","expressionStatement","replaceWith","needsBlock","childNode","isVariableDeclaration","kind","writeEndNode","replaceWithMultiple","concat","blockStatement","parentTag","parentPath","isMarkoTag"],"mappings":"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","sourcesContent":["import { resolve } from \"path\";\nimport SELF_CLOSING from \"self-closing-tags\";\nimport { types as t } from \"@marko/compiler\";\nimport {\n  getTagDef,\n  normalizeTemplateString,\n  importDefault\n} from \"@marko/babel-utils\";\nimport write from \"../../util/html-out-write\";\nimport { hasUserKey } from \"../../util/key-manager\";\nimport translateAttributes from \"./attributes\";\nimport withPreviousLocation from \"../../util/with-previous-location\";\n\nconst EMPTY_OBJECT = {};\n\n/**\n * Translates the html streaming version of a standard html element.\n */\nexport default function (path, isNullable) {\n  const {\n    hub: { file },\n    node\n  } = path;\n  const {\n    key,\n    name,\n    body: { body },\n    handlers\n  } = node;\n  const tagProperties = [];\n  const tagDef = getTagDef(path);\n  const meta = file.metadata.marko;\n\n  if (tagDef) {\n    const { parseOptions = EMPTY_OBJECT } = tagDef;\n    if (parseOptions.import) {\n      // TODO: the taglib should be updated to support this as a top level option.\n      file.metadata.marko.deps.push(resolve(tagDef.dir, parseOptions.import));\n    }\n  }\n\n  if (handlers) {\n    Object.entries(handlers).forEach(\n      ([eventName, { arguments: args, once }]) => {\n        const delegateArgs = [t.stringLiteral(eventName), args[0]];\n\n        // TODO: look into only sending this if once is true.\n        delegateArgs.push(t.booleanLiteral(once));\n\n        if (args.length > 1) {\n          delegateArgs.push(t.arrayExpression(args.slice(1)));\n        }\n\n        // TODO: why do we output eventName twice.\n        tagProperties.push(\n          t.objectProperty(\n            t.stringLiteral(`on${eventName}`),\n            t.callExpression(\n              t.memberExpression(\n                file._componentDefIdentifier,\n                t.identifier(\"d\")\n              ),\n              delegateArgs\n            )\n          )\n        );\n      }\n    );\n  }\n\n  const isHTML = file.markoOpts.output === \"html\";\n  let dataMarko = t.stringLiteral(\"\");\n\n  if (node.preserveAttrs) {\n    tagProperties.push(\n      t.objectProperty(\n        t.identifier(\"pa\"),\n        t.arrayExpression(node.preserveAttrs.map(name => t.stringLiteral(name)))\n      )\n    );\n  }\n\n  if (isHTML) {\n    if (\n      (!meta.hasStatefulTagParams &&\n        (meta.hasComponentBrowser || !meta.hasComponent)) ||\n      isPreserved(path)\n    ) {\n      const dataMarkoArgs = [t.identifier(\"out\"), file._componentDefIdentifier];\n\n      if (tagProperties.length) {\n        // TODO we should pre evaluate this if it is static.\n        dataMarkoArgs.push(t.objectExpression(tagProperties));\n      }\n\n      if (hasUserKey(path)) {\n        if (dataMarkoArgs.length === 2) {\n          dataMarkoArgs.push(t.numericLiteral(0));\n        }\n\n        dataMarkoArgs.push(key, file._componentDefIdentifier);\n      }\n\n      if (dataMarkoArgs.length > 2) {\n        dataMarko = t.callExpression(\n          importDefault(\n            file,\n            \"marko/src/runtime/html/helpers/data-marko\",\n            \"marko_props\"\n          ),\n          dataMarkoArgs\n        );\n      }\n    }\n  }\n\n  const translatedAttrs = translateAttributes(path, path.get(\"attributes\"));\n  let isSelfClosing = false;\n  let openTagEnding = \">\";\n\n  if (t.isStringLiteral(name)) {\n    if (\n      tagDef &&\n      tagDef.htmlType &&\n      (tagDef.htmlType === \"svg\" || tagDef.htmlType === \"math\")\n    ) {\n      if (!body.length) {\n        isSelfClosing = true;\n        openTagEnding = \" />\";\n      }\n    } else if (SELF_CLOSING.voidElements.indexOf(name.value) !== -1) {\n      isSelfClosing = true;\n    }\n  }\n\n  const isEmpty = isSelfClosing || !body.length;\n  let writeStartNode = normalizeTemplateString`<${name}${dataMarko}${translatedAttrs}${openTagEnding}`;\n\n  writeStartNode = withPreviousLocation(\n    isEmpty && !isSelfClosing\n      ? write`${writeStartNode}</${name}>`\n      : write`${writeStartNode}`,\n    name\n  );\n\n  if (isNullable) {\n    writeStartNode = t.ifStatement(\n      name,\n      writeStartNode,\n      t.expressionStatement(\n        t.callExpression(\n          t.memberExpression(t.identifier(\"out\"), t.identifier(\"bf\")),\n          [\n            normalizeTemplateString`f_${key}`,\n            t.identifier(\"component\"),\n            t.numericLiteral(1)\n          ]\n        )\n      )\n    );\n  }\n\n  if (isEmpty) {\n    path.replaceWith(writeStartNode);\n    return;\n  }\n\n  let needsBlock;\n  for (const childNode of body) {\n    if (t.isVariableDeclaration(childNode)) {\n      if (childNode.kind === \"const\" || childNode.kind === \"let\") {\n        needsBlock = true;\n        break;\n      }\n    }\n  }\n\n  let writeEndNode = write`</${name}>`;\n\n  if (isNullable) {\n    writeEndNode = t.ifStatement(\n      name,\n      writeEndNode,\n      t.expressionStatement(\n        t.callExpression(\n          t.memberExpression(t.identifier(\"out\"), t.identifier(\"ef\")),\n          []\n        )\n      )\n    );\n  }\n\n  path.replaceWithMultiple(\n    [writeStartNode]\n      .concat(needsBlock ? t.blockStatement(body) : body)\n      .concat(writeEndNode)\n  );\n}\n\nfunction isPreserved(path) {\n  let parentTag = path;\n  do {\n    parentTag = parentTag.parentPath.parentPath;\n    if (parentTag.get(\"isPreserved\").node === true) {\n      return true;\n    }\n  } while (t.isMarkoTag(parentTag));\n\n  return false;\n}\n"],"file":"index.js"}