{"version":3,"sources":["../../../src/taglib/core/translate-include-content.js"],"names":["enter","path","hub","file","fs","markoOpts","fileSystem","tagName","get","node","value","tagExample","args","length","buildCodeFrameError","content","isStringLiteral","dir","nodePath","dirname","opts","sourceFileName","fullPath","resolve","stat","statSync","isFile","Error","replaceWith","t","markoPlaceholder","stringLiteral","readFileSync","toString"],"mappings":"kJAAA;AACA;AACA;;AAEO,SAASA,KAAT,CAAeC,IAAf,EAAqB;AAC1B,QAAM;AACJC,IAAAA,GAAG,EAAE,EAAEC,IAAF,EADD;AAEFF,EAAAA,IAFJ;AAGA,kCAAeA,IAAf;AACA,sCAAmBA,IAAnB;;AAEA,QAAMG,EAAE,GAAGD,IAAI,CAACE,SAAL,CAAeC,UAA1B;AACA,QAAMC,OAAO,GAAGN,IAAI,CAACO,GAAL,CAAS,MAAT,EAAiBC,IAAjB,CAAsBC,KAAtC;AACA,QAAMC,UAAU,GAAI,IAAGJ,OAAQ,yBAA/B;AACA,QAAMK,IAAI,GAAGX,IAAI,CAACO,GAAL,CAAS,WAAT,CAAb;;AAEA,MAAII,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB;AACrB,UAAMZ,IAAI,CAACa,mBAAL;AACH,8CAAyCH,UAAW,GADjD,CAAN;;AAGD;;AAED,QAAM,CAACI,OAAD,IAAYH,IAAlB;;AAEA,MAAI,CAACG,OAAO,CAACC,eAAR,EAAL,EAAgC;AAC9B,UAAMD,OAAO,CAACD,mBAAR;AACH,uBAAkBH,UAAW,2BAD1B,CAAN;;AAGD;;AAED,QAAMM,GAAG,GAAGC,cAASC,OAAT,CAAiBhB,IAAI,CAACiB,IAAL,CAAUC,cAA3B,CAAZ;AACA,QAAMC,QAAQ,GAAGJ,cAASK,OAAT,CAAiBN,GAAjB,EAAsBF,OAAO,CAACN,IAAR,CAAaC,KAAnC,CAAjB;;AAEA,MAAI;AACF,UAAMc,IAAI,GAAGpB,EAAE,CAACqB,QAAH,CAAYH,QAAZ,CAAb;;AAEA,QAAI,CAACE,IAAI,CAACE,MAAL,EAAL,EAAoB;AAClB,YAAM,IAAIC,KAAJ,EAAN;AACD;AACF,GAND,CAME,MAAM;AACN,UAAMZ,OAAO,CAACD,mBAAR,CAA6B,4BAA2BP,OAAQ,IAAhE,CAAN;AACD;;AAEDN,EAAAA,IAAI,CAAC2B,WAAL;AACEC,kBAAEC,gBAAF;AACED,kBAAEE,aAAF,CAAgB3B,EAAE,CAAC4B,YAAH,CAAgBV,QAAhB,EAA0BW,QAA1B,CAAmC,OAAnC,CAAhB,CADF;AAEE1B,EAAAA,OAAO,KAAK,cAFd,CADF;;;AAMD","sourcesContent":["import nodePath from \"path\";\nimport { types as t } from \"@marko/compiler\";\nimport { assertNoParams, assertNoAttributes } from \"@marko/babel-utils\";\n\nexport function enter(path) {\n  const {\n    hub: { file }\n  } = path;\n  assertNoParams(path);\n  assertNoAttributes(path);\n\n  const fs = file.markoOpts.fileSystem;\n  const tagName = path.get(\"name\").node.value;\n  const tagExample = `<${tagName}(\"./path-to-file.ext\")>`;\n  const args = path.get(\"arguments\");\n\n  if (args.length !== 1) {\n    throw path.buildCodeFrameError(\n      `A single path argument is required for ${tagExample}.`\n    );\n  }\n\n  const [content] = args;\n\n  if (!content.isStringLiteral()) {\n    throw content.buildCodeFrameError(\n      `The argument to ${tagExample} must be a static string.`\n    );\n  }\n\n  const dir = nodePath.dirname(file.opts.sourceFileName);\n  const fullPath = nodePath.resolve(dir, content.node.value);\n\n  try {\n    const stat = fs.statSync(fullPath);\n\n    if (!stat.isFile()) {\n      throw new Error();\n    }\n  } catch {\n    throw content.buildCodeFrameError(`Unable to find file for <${tagName}>.`);\n  }\n\n  path.replaceWith(\n    t.markoPlaceholder(\n      t.stringLiteral(fs.readFileSync(fullPath).toString(\"utf-8\")),\n      tagName === \"include-text\"\n    )\n  );\n}\n"],"file":"translate-include-content.js"}