"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");exports.__esModule = true;exports.enter = enter;var _path = _interopRequireDefault(require("path"));
var _compiler = require("@marko/compiler");
var _babelUtils = require("@marko/babel-utils");

function enter(path) {
  const {
    hub: { file } } =
  path;
  (0, _babelUtils.assertNoParams)(path);
  (0, _babelUtils.assertNoAttributes)(path);

  const fs = file.markoOpts.fileSystem;
  const tagName = path.get("name").node.value;
  const tagExample = `<${tagName}("./path-to-file.ext")>`;
  const args = path.get("arguments");

  if (args.length !== 1) {
    throw path.buildCodeFrameError(
    `A single path argument is required for ${tagExample}.`);

  }

  const [content] = args;

  if (!content.isStringLiteral()) {
    throw content.buildCodeFrameError(
    `The argument to ${tagExample} must be a static string.`);

  }

  const dir = _path.default.dirname(file.opts.sourceFileName);
  const fullPath = _path.default.resolve(dir, content.node.value);

  try {
    const stat = fs.statSync(fullPath);

    if (!stat.isFile()) {
      throw new Error();
    }
  } catch {
    throw content.buildCodeFrameError(`Unable to find file for <${tagName}>.`);
  }

  path.replaceWith(
  _compiler.types.markoPlaceholder(
  _compiler.types.stringLiteral(fs.readFileSync(fullPath).toString("utf-8")),
  tagName === "include-text"));


}
//# sourceMappingURL=translate-include-content.js.map