"use strict";var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");require("../types/patch");

var t = _interopRequireWildcard(require("@babel/types"));
var _traverse = _interopRequireWildcard(require("@babel/traverse"));
var _definitions = require("../types/definitions");

_definitions.MARKO_TYPES.forEach(typeName => {
  const checkKey = `is${typeName}`;
  const assertKey = `assert${typeName}`;
  const checkFn = t[checkKey];
  const assertFn = t[assertKey];
  _traverse.NodePath.prototype[checkKey] = function (opts) {
    return checkFn(this.node, opts);
  };
  _traverse.NodePath.prototype[assertKey] = function (opts) {
    assertFn(this.node, opts);
  };
});

_definitions.MARKO_ALIAS_TYPES.forEach(aliasName => {
  const checkKey = `is${aliasName}`;
  const originalProtoCheck = _traverse.NodePath.prototype[checkKey];
  _traverse.NodePath.prototype[checkKey] = function (opts) {
    return (
      t.is(aliasName, this.node, opts) ||
      originalProtoCheck.call(this, this.node, opts));

  };
});

// Adds a one time patch to the scope collector visitors to include
// Marko bindings for params and tag vars.
const originalCrawl = _traverse.Scope.prototype.crawl;
_traverse.Scope.prototype.crawl = function () {
  const path = this.path;
  const originalTraverse = path.traverse;
  path.traverse = function (visitor) {
    Object.assign(
    _traverse.default.explode(visitor),
    _traverse.default.explode({
      MarkoTagBody(body) {
        for (const param of body.get("params")) {
          body.scope.registerBinding("param", param);
        }
      },
      MarkoTag(tag) {
        if (tag.has("var")) {
          tag.scope.registerBinding("local", tag.get("var"), tag);
        }
      } }));



    path.traverse = originalTraverse;
    return originalTraverse.apply(this, arguments);
  };

  _traverse.Scope.prototype.crawl = originalCrawl;
  originalCrawl.apply(this, arguments);
};
//# sourceMappingURL=patch.js.map